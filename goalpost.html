<!DOCTYPE html><html><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type" /><meta content="width=device-width, initial-scale=1" name="viewport" /><!--replace-start-0--><!--replace-start-5--><!--replace-start-8--><title>Goalpost - Noah&#39;s Knowledge Graph</title><!--replace-end-8--><!--replace-end-5--><!--replace-end-0--><link href="https://cdn.jsdelivr.net/npm/fomantic-ui@2.8.7/dist/semantic.min.css" rel="stylesheet" /><link href="https://fonts.googleapis.com/css?family=Merriweather|Libre+Franklin|Roboto+Mono&amp;display=swap" rel="stylesheet" /><!--replace-start-1--><!--replace-start-4--><!--replace-start-7--><link href="https://raw.githubusercontent.com/srid/neuron/master/assets/neuron.svg" rel="icon" /><meta content="Noah Pederson" name="author" /><meta content="One thing that has always stuck out to me about the Go programming language is it‚Äôs incredibly strong concurrency model. Go is aggressively simple as a language, and it‚Äôs asynchronous architecture is no different. Channels are a beautiful implementation of a buffered FIFO queue which have an infinit" name="description" /><link href="https://packetlost.dev/goalpost.html" rel="canonical" /><meta content="Goalpost" property="og:title" /><meta content="Noah&#39;s Knowledge Graph" property="og:site_name" /><meta content="article" property="og:type" /><script type="application/ld+json">[{"@context":"https://schema.org","itemListElement":[{"name":"Blogposts","item":"https://packetlost.dev/blogposts.html","@type":"ListItem","position":1}],"@type":"BreadcrumbList"}]</script><style type="text/css">body{background-color:#eeeeee !important;font-family:"Libre Franklin", serif !important}body .ui.container{font-family:"Libre Franklin", serif !important}body h1, h2, h3, h4, h5, h6, .ui.header, .headerFont{font-family:"Merriweather", sans-serif !important}body code, pre, tt, .monoFont{font-family:"Roboto Mono","SFMono-Regular","Menlo","Monaco","Consolas","Liberation Mono","Courier New", monospace !important}body div.z-index p.info{color:#808080}body div.z-index ul{list-style-type:square;padding-left:1.5em}body div.z-index .uplinks{margin-left:0.29999em}body .zettel-content h1#title-h1{background-color:rgba(100,53,201,0.1)}body nav.bottomPane{background-color:rgba(100,53,201,2.0e-2)}body div#footnotes{border-top-color:#6435c9}body p{line-height:150%}body img{max-width:100%}body .deemphasized{font-size:0.94999em}body .deemphasized:hover{opacity:1}body .deemphasized:not(:hover){opacity:0.69999}body .deemphasized:not(:hover) a{color:#808080 !important}body div.container.universe{padding-top:1em}body div.zettel-view ul{padding-left:1.5em;list-style-type:square}body div.zettel-view .pandoc .highlight{background-color:#ffff00}body div.zettel-view .pandoc .ui.disabled.fitted.checkbox{margin-right:0.29999em;vertical-align:middle}body div.zettel-view .zettel-content .metadata{margin-top:1em}body div.zettel-view .zettel-content .metadata div.date{text-align:center;color:#808080}body div.zettel-view .zettel-content h1{padding-top:0.2em;padding-bottom:0.2em;text-align:center}body div.zettel-view .zettel-content h2{border-bottom:solid 1px #4682b4;margin-bottom:0.5em}body div.zettel-view .zettel-content h3{margin:0px 0px 0.4em 0px}body div.zettel-view .zettel-content h4{opacity:0.8}body div.zettel-view .zettel-content div#footnotes{margin-top:4em;border-top-style:groove;border-top-width:2px;font-size:0.9em}body div.zettel-view .zettel-content div#footnotes ol > li > p:only-of-type{display:inline;margin-right:0.5em}body div.zettel-view .zettel-content aside.footnote-inline{width:30%;padding-left:15px;margin-left:15px;float:right;background-color:#d3d3d3}body div.zettel-view .zettel-content .overflows{overflow:auto}body div.zettel-view .zettel-content code{margin:auto auto auto auto;font-size:100%}body div.zettel-view .zettel-content p code, li code, ol code{padding:0.2em 0.2em 0.2em 0.2em;background-color:#f5f2f0}body div.zettel-view .zettel-content pre{overflow:auto}body div.zettel-view .zettel-content dl dt{font-weight:bold}body div.zettel-view .zettel-content blockquote{background-color:#f9f9f9;border-left:solid 10px #cccccc;margin:1.5em 0px 1.5em 0px;padding:0.5em 10px 0.5em 10px}body div.zettel-view .zettel-content.raw{background-color:#dddddd}body .ui.label.zettel-tag{color:#000000}body .ui.label.zettel-tag a{color:#000000}body nav.bottomPane ul.backlinks > li{padding-bottom:0.4em;list-style-type:disc}body nav.bottomPane ul.context-list > li{list-style-type:lower-roman}body .footer-version img{-webkit-filter:grayscale(100%);-moz-filter:grayscale(100%);-ms-filter:grayscale(100%);-o-filter:grayscale(100%);filter:grayscale(100%)}body .footer-version img:hover{-webkit-filter:grayscale(0%);-moz-filter:grayscale(0%);-ms-filter:grayscale(0%);-o-filter:grayscale(0%);filter:grayscale(0%)}body .footer-version, .footer-version a, .footer-version a:visited{color:#808080}body .footer-version a{font-weight:bold}body .footer-version{margin-top:1em !important;font-size:0.69999em}@media only screen and (max-width: 768px){body div#zettel-container{margin-left:0.4em !important;margin-right:0.4em !important}}body span.zettel-link-container span.zettel-link a{color:#6435c9;font-weight:bold;text-decoration:none}body span.zettel-link-container span.zettel-link a:hover{background-color:rgba(100,53,201,0.1)}body span.zettel-link-container span.extra{color:auto}body span.zettel-link-container.errors{border:solid 1px #ff0000}body span.zettel-link-container.errors span.zettel-link a:hover{text-decoration:none !important;cursor:not-allowed}body [data-tooltip]:after{font-size:0.69999em}body div.tag-tree div.node{font-weight:bold}body div.tag-tree div.node a.inactive{color:#555555}body .tree.flipped{-webkit-transform:rotate(180deg);-moz-transform:rotate(180deg);-ms-transform:rotate(180deg);-o-transform:rotate(180deg);transform:rotate(180deg)}body .tree{overflow:auto}body .tree ul.root{padding-top:0px;margin-top:0px}body .tree ul{position:relative;padding:1em 0px 0px 0px;white-space:nowrap;margin:0px auto 0px auto;text-align:center}body .tree ul::after{content:"";display:table;clear:both}body .tree ul:last-child{padding-bottom:0.1em}body .tree li{display:inline-block;vertical-align:top;text-align:center;list-style-type:none;position:relative;padding:1em 0.5em 0em 0.5em}body .tree li::before{content:"";position:absolute;top:0px;right:50%;border-top:solid 2px #cccccc;width:50%;height:1.19999em}body .tree li::after{content:"";position:absolute;top:0px;right:50%;border-top:solid 2px #cccccc;width:50%;height:1.19999em}body .tree li::after{right:auto;left:50%;border-left:solid 2px #cccccc}body .tree li:only-child{padding-top:0em}body .tree li:only-child::after{display:none}body .tree li:only-child::before{display:none}body .tree li:first-child::before{border-style:none;border-width:0px}body .tree li:first-child::after{border-radius:5px 0px 0px 0px}body .tree li:last-child::after{border-style:none;border-width:0px}body .tree li:last-child::before{border-right:solid 2px #cccccc;border-radius:0px 5px 0px 0px}body .tree ul ul::before{content:"";position:absolute;top:0px;left:50%;border-left:solid 2px #cccccc;width:0px;height:1.19999em}body .tree li div.forest-link{border:solid 2px #cccccc;padding:0.2em 0.29999em 0.2em 0.29999em;text-decoration:none;display:inline-block;border-radius:5px 5px 5px 5px;color:#333333;position:relative;top:2px}body .tree.flipped li div.forest-link{-webkit-transform:rotate(180deg);-moz-transform:rotate(180deg);-ms-transform:rotate(180deg);-o-transform:rotate(180deg);transform:rotate(180deg)}</style><script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism.min.css" rel="stylesheet" /><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-core.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/autoloader/prism-autoloader.min.js"></script><!--replace-end-7--><!--replace-end-4--><!--replace-end-1--></head><body><div class="ui fluid container universe"><!--replace-start-2--><!--replace-start-3--><!--replace-start-6--><nav class="flipped tree deemphasized" id="zettel-uptree" style="transform-origin: 50%"><ul class="root"><li><ul><li><div class="forest-link"><span class="zettel-link-container"><span class="zettel-link" title="2021-03-03T10:05"><a href="blogposts.html">Blogposts</a></span></span></div></li></ul></li></ul></nav><div class="ui text container" id="zettel-container" style="position: relative"><div class="zettel-view"><article class="ui raised attached segment zettel-content"><div class="pandoc"><h1 id="title-h1">Goalpost</h1><h2 id="a-durable-embeddable-worker-queue-for-golang">a durable, embeddable, worker queue for golang</h2><h5 id="original-article"><a href="http://tilde.club/~ngp/blob/posts/goalpost/">Original article</a></h5><p>One thing that has always stuck out to me about the Go programming language is it‚Äôs incredibly strong concurrency model. Go is aggressively simple as a language, and it‚Äôs asynchronous architecture is no different. Channels are a beautiful implementation of a buffered FIFO queue which have an infinite number of applications. There‚Äôs no <code>Thread</code> classes, just a simple <code>go</code> in front of a function call. It‚Äôs great! You can probably tell, but I enjoy working with Go a lot.</p><p>With that, I‚Äôd like to introduce a small side-project of mine. I call it <a href="https://github.com/chiefnoah/goalpost/blob/master/queue.go">goalpost</a>. It‚Äôs a simple, embeddable, worker queue library. It seeks to be a simple way to reliably do <em>work</em> in uncertain runtime environments.</p><!--more-->
<h2 id="whats-a-work-queue">What‚Äôs a work queue?</h2><p>Work or job queues are a way of reliably executing a task in an asyncronous manner. This idea is that when you push a message onto the queue, one or more workers can pick up the message and begin acting on it, typically in a different process or thread. One of the most popular worker queue implementations is <a href="https://www.rabbitmq.com/">RabbitMQ</a>. RabbitMQ is incredibly mature and robust, and one of the most widely used queue systems in the world. It supports durability, permissions, federation, and many other advanced features. There are many other queues (<a href="https://redis.io/">redis</a>, for example, can be used as a queue), RabbitMQ is just <em>one</em> of the many out there.</p><blockquote><p>If RabbitMQ is so great, why did you make goalpost?</p></blockquote><p>Good question! You see, while RabbitMQ is great, it‚Äôs a little on the heavy side and requires a fair bit of setup. Further, it requires binding to a TCP port in order to work. While that‚Äôs <em>usually</em> not much of a problem, there are scenarios when that‚Äôs undesirable or not even an option.</p><p>Goalpost started as part of another project (which isn‚Äôt open source, sorry!), but was designed in a way that it was easy to rip out and turn into it‚Äôs own external dependency for the project.</p><p>The service was intended to be run on a Linux system where binding to a TCP port wasn‚Äôt an option, and the server could restart at almost any point. The existing system, written as a combination of bash and python scripts, worked but was susceptible to failing ungracefully when the server rebooted, and worse, wouldn‚Äôt retry when the server came back up. This means that jobs could get ‚Äúlost‚Äù and never finish execution. Ultimately, this resulted in little more than a minor inconvenience for me, but I wanted the whole thing to be completely hands-off as much as possible.</p><h2 id="exploration">Exploration</h2><p>Initially, I looked into other options. Like any good developer, I‚Äôm lazy and don‚Äôt want to rewrite something someone has already done. Ok, part of me really wanted to try writing a queue, but if it already existed I would‚Äôve taken the lazy path üôÉ</p><p>There were a few projects that came close to what I needed, but didn‚Äôt have everything I was looking for.</p><p><a href="https://github.com/beeker1121/goque">goque</a> seemed promising, but it doesn‚Äôt actually implement a work queue, and it seems the project is dead (last commit was 3 years ago).</p><p><a href="https://github.com/joncrlsn/dque">dque</a> was another one I looked at. I actually like dque a lot, but again, not a worker queue. I considered trying to modify it it and add worker queue, but after looking through the code, decided it would probably be easier to just start a new project.</p><p>This wonderful post on OpsDash on <a href="https://www.opsdash.com/blog/job-queues-in-go.html">Job Queues in Go</a> was super helpful, but lacked durability, given that it relies entirely on go channels.</p><p>If there were other options, they certainly made themselves hard to find!</p><h2 id="choosing-a-storage-backend">Choosing a storage backend</h2><p>One of the primary goals of goalpost was to be able to survive un-expected restarts, and also shutdown gracefully when possible. As such, it needs a way of persisting jobs to disk.</p><p>Go has several projects that seek to handle everything from in-memory, embedded SQL engines, to persistent, fast, key-value stores. Etcd, a popular distributed key-value store, is backed by a forked version of boltdb. The <a href="https://github.com/boltdb/bolt">original project</a> was set to read-only awhile ago, and was subsequently forked by the etcd project to continue adding new features as the etcd needed. Both would work, as the interface and practical use-case is the same for both, so I went with etcd‚Äôs fork: bbolt.</p><blockquote><p>Key-value stores aren‚Äôt a great way to do queues</p></blockquote><p>You‚Äôre probably right, but when combined with a buffered notifications system, they can get the job done well enough. An embedded SQL engine would‚Äôve been overkill for this, and I didn‚Äôt want to write my own storage backend. Lazy, remember?</p><h2 id="writing-some-code">Writing some code‚Ä¶</h2><p>I‚Äôm not going to go into too much detail on my process for writing goalpost, mostly because it‚Äôs been months since I originally wrote it. It lived for awhile as part of that other project, until I finally got the motivation to rip it out and properly document everything.</p><p>One of the first things I did was define the <code>Job</code> struct and the <code>JobStatus</code> constant types. I wanted to get the basics of what state the jobs could be in out of the way first. It ended up working out pretty well, as the only fields that were added to <code>Job</code> was the <code>Message</code> field, and nothing was added to <code>JobStatus</code>. I <em>did</em> reference parts of the documentation for RabbitMQ‚Äôs worker model, which helped with the <code>JobStatus</code> definitions, with my implementation being a subset of RabbitMQ‚Äôs job states with some modifications to the semantics. There may be room for a new state such as <code>new</code> to better indicate that a job has not been started by a worker at all yet, but as of right now it‚Äôs not strictly needed.</p><p>The possible job states are as follows:</p><p><code>uack</code> - This is the original state a job is in when it‚Äôs pushed to the queue. The meaning is ‚Äúunacknowledged‚Äù, meaning the job has not been completed yet. Workers <em>do</em> update the state, but it‚Äôs to <code>uack</code>.</p><p><code>nack</code> - This is similar to the AMQP extension, except it simply means ‚Äújob processing failed, but should put back on the queue and retried‚Äù</p><p><code>ack</code> - The basic ‚Äòacknowledged‚Äô state. This means a job has completed processing and should not be re-attempted. ‚ÄúCompleted‚Äù</p><p><code>failed</code> - Indicates a hard failure in the job. An unrecoverable error, and the job should not be reattempted.</p><p>It‚Äôs worth pointing out that the workers <code>DoWork</code> function should <em>never</em> modify the job status themselves. Doing so could potentially caused undefined behavior.</p><h3 id="creating-a-queue-registering-workers-and-looping-forever">Creating a queue registering workers and looping forever</h3><p>Creating a queue is pretty easy. You call <code>goalpost.Init(queueID)</code> with a unique id for the queue, which is used to initialize or open the database. A WaitGroup and a chan are created for handling shutdown and job events. Once a queue is initialized, you need to register a worker in order to start processing jobs.</p><p>When a worker is registered, the queue does some setup that allows it to keep track of workers. It then executes the main poll loop with the worker in a separate goroutine, sleeping for 500 milliseconds (now configurable in <code>Queue</code>) after checking to either shut down or work a job. Context.context can be used to signal to your <code>DoWork</code> function that the queue has received a signal to stop, and it should make an attempt to exit early.</p><p>When <code>PushBytes</code> is called, a <code>Job</code> is created and written to the boltdb database, then a notification with the resuling JobID is sent to the chan that was created when the queue was initialized. A worker reads from the chan, receiving the JobID, which it then reads from the database for processing.</p><p>When a job is marked as <code>ack</code>ed or <code>failed</code>, the job gets moved to a second bucket, which is purely used for reference. This also should help with performance in certain scenarios, such as when trying to resume uncompleted jobs where the entire bucket is scanned for <code>uack</code>ed jobs.</p><h3 id="using-goalpost">Using goalpost</h3><p>Goalpost seeks to be an easy to use. How easy? Well I think it‚Äôs pretty easy, but you decide how easy it is for yourself.</p><p>First, you need to of course import the goalpost package:</p><pre><code class="golang language-golang">import &quot;git.packetlostandfound.us/chiefnoah/goalpost&quot;</code></pre><p>Too slow? Ok fine, here‚Äôs a basic implementation for a Worker. This is basically copy pasted from <a href="https://github.com/chiefnoah/goalpost/blob/master/examples/basic.go">the example</a>, but I‚Äôll include it here for redundancy‚Äôs sake:</p><pre><code class="golang language-golang">type worker struct {
	id string
}

func (w *worker) ID() string {
	return w.id
}

func (w *worker) DoWork(ctx context.Context, j *goalpost.Job) error {
	//do something cool!
	fmt.Printf(&quot;Hello, %s\n&quot;, j.Data)
	//Something broke, but we should retry it...
	if j.RetryCount &lt; 9 { //try 10 times
		return goalpost.NewRecoverableWorkerError(&quot;Something broke, try again&quot;)
	}

	//Something *really* broke, don&#39;t retry
	//return errors.New(&quot;Something broke, badly&quot;)

	//Everything&#39;s fine, we&#39;re done here
	return nil
}</code></pre><p>You can do whatever you want in the DoWork function. It‚Äôs executed in a separate goroutine from the main thread, so keep that in mind if you‚Äôre interacting with things outside of the worker thread. I recommend storing configuration and shared types (like a database connection) in the type that implements the Worker interface, in this case, the <code>worker</code> struct.</p><p>Now is probably a good time to talk about error handling. Errors returned from the DoWork function can be of two types:</p><ul><li><code>goalpost.RecoverableWorkerError</code></li><li>everything else</li></ul><p><code>goalpost.RecoverableWorkerError</code> is used to indicate a temporary failure, for example a timeout on a web request. When the queue receives an error of that type from a <code>DoWork</code> function, it increments the <code>Jon.RetryCount</code>, marks the job as <code>nack</code>ed, and pushes the event back onto the queue. If there are workers available to process the job, it will be processed again immediately. It‚Äôs recommended that you check <code>Job.RetryCount</code> when returning <code>RecoverableWorkerError</code>s, as failing to do so could result in a job being retried infinitely. Maybe that‚Äôs what you want? But chances are it‚Äôs <strong>not</strong>.</p><p>Next up is initializing the <code>Queue</code> and registering a worker:</p><pre><code class="golang language-golang">func main() {

	//Init a queue
	q, _ := goalpost.Init(eventQueueID)
	//remember to handle your errors :)

	//Create a worker with id &quot;worker-id&quot;
	w := &amp;worker{
		id: &quot;worker-1&quot;,
	}
	//register the worker, so it can do work
	q.RegisterWorker(w)

	//Let&#39;s do some work...
	q.PushBytes([]byte(&quot;World&quot;))
	//You should see &quot;Hello, World&quot; printed 10 times

	//Make sure your process doesn&#39;t exit before your workers can do their work
	time.Sleep(10 * time.Second)

	//Remember to close your queue when you&#39;re done using it
	q.Close()
}</code></pre><p>You can initialize a queue from anywhere, here we do it in <code>main</code> for simplicity. The <code>Queue</code> type is thread safe, but you <em>cannot</em> have multiple instances of a <code>Queue</code> with the same ID/filepath. This is a limitation of boltdb/bbolt. Attempts to initialize a second queue with the same database file will result in errors.</p><p>Once you have a queue initialized, you need to create an instance of your <code>Worker</code> type and register it with the queue with the <code>RegisterWorker</code> method. You can register the same worker instance multiple times, but logging will report the same ID, and you must be mindful of shared resources in <code>*w</code>. I recommend creating multiple instances of your worker type and registering each once.</p><p>With some workers watching the queue, you can now push data into the queue for processing. In the example, we only push a byte encoded string, but any <code>[]byte</code> will work. For my application, I use <code>encoding/gob</code> to pass whole structs to my worker.</p><p>Another thing to remember is that you need to keep your main process alive. If <code>main</code> exits, the goroutines with your workers will receive a signal to shutdown, and may leave unprocessed jobs in the queue. There currently is no way to see if there are jobs that haven‚Äôt been started, though such a feature could be implemented if the need arises.</p><p>I use the following snippet followed by a eternally blocking <code>http.ListenAndServe</code> call to gracefully shutdown the queue:</p><pre><code class="golang language-golang">
c := make(chan os.Signal)
signal.Notify(c, os.Interrupt, syscall.SIGTERM)
signal.Notify(c, os.Interrupt, syscall.SIGINT)
go func() {
	&lt;-c
	log.Printf(&quot;Closing queue...&quot;)
	q.Close()

	os.Exit(0)
}()</code></pre><h3 id="closing-things-out">Closing things out</h3><p>I had a lot of fun writing this little library, and I hope someone else can find it useful! It‚Äôs my first library that I‚Äôm opening up to the public, so things may be a little rough. As always, feel free to shoot me an email at noah <strong>at</strong> packetlost.dev with feedback or patches. Pull requests on GitHub also welcome!</p><p>Oh, and remember to call <code>.Close()</code></p></div><div class="metadata"><div class="date" title="Zettel date"><time datetime="2020-06-01T12:00">2020-06-01</time></div></div></article><nav class="ui attached segment deemphasized backlinksPane" id="neuron-backlinks-pane"><h3 class="ui header">Backlinks</h3><ul class="backlinks"><li><span class="zettel-link-container cf"><span class="zettel-link" title="2020-10-20T22:35"><a href="dd530aa1.html">Programming Languages</a></span></span><ul class="context-list" style="zoom: 85%;"></ul></li><li><span class="zettel-link-container cf"><span class="zettel-link"><a href=".">Noah‚Äôs Knowledgebase</a></span></span><ul class="context-list" style="zoom: 85%;"></ul></li></ul><h3 class="ui header"><span title="Backlinks from folgezettel parents">Uplinks</span></h3><ul class="backlinks"><li><span class="zettel-link-container folge"><span class="zettel-link" title="2021-03-03T10:05"><a href="blogposts.html">Blogposts</a><span data-nosnippet="" style="user-select: none; color: gray" title="Folgezettel">#</span></span></span><ul class="context-list" style="zoom: 85%;"></ul></li></ul></nav><nav class="ui attached segment deemphasized bottomPane" id="neuron-tags-pane"><div><span class="ui basic label zettel-tag" title="Tag">blog/published</span><span class="ui basic label zettel-tag" title="Tag">software/languages/go</span></div></nav><nav class="ui bottom attached icon compact inverted menu violet" id="neuron-nav-bar"><!--replace-start-9--><a class="item" href="." title="Home"><i class="home icon"></i></a><!--replace-end-9--><a class="item" href="https://github.com/chiefnoah/zettelkasten/edit/master/./goalpost.md" title="Edit this page"><i class="edit icon"></i></a><a class="right item" href="impulse.html" title="Open Impulse"><i class="wave square icon"></i></a></nav></div></div><!--replace-end-6--><!--replace-end-3--><!--replace-end-2--><div class="ui center aligned container footer-version"><div class="ui tiny image"><a href="https://neuron.zettel.page"><img alt="logo" src="https://raw.githubusercontent.com/srid/neuron/master/assets/neuron.svg" title="Generated by Neuron 1.9.25.1" /></a></div></div></div></body></html>